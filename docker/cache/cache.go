// Package cache provides a cache of Docker containers and images.
// It also provides a mechanism to receive events from Docker and
// update the cache accordingly.
package cache

import (
	"sync"

	"github.com/docker/docker/api/types/events"
	"github.com/kernaxis/gmd/docker/client"
	"github.com/kernaxis/gmd/docker/types"
)

// Cache represents a cache of Docker containers and images.
type Cache struct {
	cli               *client.Client              // cli is the Docker client used to interact with the Docker daemon.
	mu                sync.RWMutex                // mu is a read-write mutex used to protect access to the cache.
	images            map[string]*types.Image     // images is a map of image IDs to their corresponding corresponding Image objects.
	containers        map[string]*types.Container // containers is a map of container IDs to their respective Container objects.
	ievents           <-chan events.Message       // ieEvents is a channel of events received from Docker.
	ierrors           <-chan error                // ierrors is a channel of errors received from Docker.
	events            chan Event                  // events is a channel of events generated by the cache, such as when the cache is updated or when a container is deleted.
	containerDeletion chan string                 // containerDeletion is a channel of container IDs that are being deleted.
}

// NewCache returns a new Cache object.
func NewCache(cli *client.Client) *Cache {
	c := &Cache{
		cli:               cli,
		images:            make(map[string]*types.Image),
		containers:        make(map[string]*types.Container),
		events:            make(chan Event, 20),
		containerDeletion: make(chan string, 20),
	}

	return c
}

// LoadAndStart loads the cache with the current state of the Docker daemon
// and starts listening for events.
func (c *Cache) LoadAndStart() error {
	c.ievents, c.ierrors = c.cli.StartEvents()

	imgs := c.snapshotImages()
	c.mu.Lock()
	for _, img := range imgs {
		c.images[img.ID] = img
	}
	c.mu.Unlock()

	c.events <- Event{EventType: ImagesLoadedEventType}

	conts := c.snapshotContainers()
	c.mu.Lock()
	for _, cont := range conts {
		c.containers[cont.ID] = cont
	}
	c.mu.Unlock()

	c.events <- Event{EventType: ContainersLoadedEventType}

	go c.listenEvents()
	go c.containerDeleteWorker()

	// for i := range m.containers {
	// 	go m.checkUpdate(m.containers[i])
	// 	go m.watchStats(m.containers[i])
	// }

	return nil
}
